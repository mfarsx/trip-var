baf79948788debc8464d3de3f24de0f5
const userRepository = require('../repositories/user.repository');
const {
  ValidationError,
  UnauthorizedError,
  NotFoundError,
  ConflictError
} = require('../utils/errors');
const {
  redisUtils
} = require('../middleware/redisCache');
const COUNTRIES = require('../utils/countries');
const BaseService = require('./base.service');
class UserService extends BaseService {
  /**
   * Register a new user
   * @param {Object} userData - User registration data
   * @returns {Promise<Object>} User and token
   */
  async register(userData) {
    const {
      email,
      password,
      name,
      dateOfBirth,
      nationality
    } = userData;

    // Check if user already exists
    const existingUser = await userRepository.findByEmail(email);
    if (existingUser) {
      throw new ConflictError('Email already registered');
    }

    // Format dateOfBirth to handle timezone issues
    const formattedDateOfBirth = dateOfBirth ? new Date(dateOfBirth) : undefined;

    // Create new user
    const user = await userRepository.create({
      email,
      password,
      name,
      dateOfBirth: formattedDateOfBirth,
      nationality
    });

    // Generate token
    const token = user.generateAuthToken();

    // Remove password from output
    user.password = undefined;
    return {
      user,
      token
    };
  }

  /**
   * Login user
   * @param {Object} credentials - Login credentials
   * @returns {Promise<Object>} User and token
   */
  async login(credentials) {
    const {
      email,
      password
    } = credentials;

    // Check if email and password exist
    if (!email || !password) {
      throw new ValidationError('Please provide email and password');
    }

    // Check if user exists && password is correct
    const user = await userRepository.findByEmailWithPassword(email);
    if (!user || !(await user.comparePassword(password))) {
      throw new UnauthorizedError('Invalid credentials');
    }

    // Generate token
    const token = user.generateAuthToken();

    // Remove password from output
    user.password = undefined;
    return {
      user,
      token
    };
  }

  /**
   * Get user profile by ID
   * @param {string} userId - User ID
   * @returns {Promise<Object>} User profile with computed fields
   */
  async getProfile(userId) {
    const user = await userRepository.findById(userId, {
      select: '-password',
      lean: true
    });
    if (!user) {
      throw new NotFoundError('User not found');
    }

    // Calculate age if dateOfBirth exists
    if (user.dateOfBirth) {
      user.age = this.calculateAge(user.dateOfBirth);
    }

    // Get country code if nationality exists
    if (user.nationality) {
      const country = COUNTRIES.find(c => c.name === user.nationality);
      if (country) {
        user.countryCode = country.code;
      }
    }
    return user;
  }

  /**
   * Update user profile
   * @param {string} userId - User ID
   * @param {Object} updateData - Data to update
   * @returns {Promise<Object>} Updated user profile
   */
  async updateProfile(userId, updateData) {
    // Don't allow password updates here
    if (updateData.password) {
      throw new ValidationError('This route is not for password updates. Please use /auth/update-password');
    }

    // Filter out unwanted fields that are not allowed to be updated
    const filteredData = this.filterAllowedFields(updateData, 'name', 'email', 'dateOfBirth', 'nationality');
    const updatedUser = await userRepository.updateById(userId, filteredData, {
      select: '-password'
    });

    // Calculate age if dateOfBirth exists
    if (updatedUser.dateOfBirth) {
      updatedUser.age = this.calculateAge(updatedUser.dateOfBirth);
    }

    // Get country code if nationality exists
    if (updatedUser.nationality) {
      const country = COUNTRIES.find(c => c.name === updatedUser.nationality);
      if (country) {
        updatedUser.countryCode = country.code;
      }
    }
    return updatedUser;
  }

  /**
   * Update user password
   * @param {string} userId - User ID
   * @param {Object} passwordData - Current and new password
   * @returns {Promise<Object>} New token
   */
  async updatePassword(userId, passwordData) {
    const {
      currentPassword,
      newPassword
    } = passwordData;
    if (!currentPassword || !newPassword) {
      throw new ValidationError('Please provide current and new password');
    }
    const user = await userRepository.findById(userId, {
      select: '+password'
    });
    if (!user) {
      throw new NotFoundError('User not found');
    }
    if (!(await user.comparePassword(currentPassword))) {
      throw new UnauthorizedError('Current password is incorrect');
    }
    await userRepository.updatePassword(userId, newPassword);

    // Get updated user to generate new token
    const updatedUser = await userRepository.findById(userId);
    const token = updatedUser.generateAuthToken();
    return {
      token
    };
  }

  /**
   * Delete user account (soft delete)
   * @param {string} userId - User ID
   * @returns {Promise<void>}
   */
  async deleteAccount(userId) {
    await userRepository.softDelete(userId);

    // Clear user-related cache
    await this.clearUserCache(userId);
  }

  /**
   * Get all users (admin only)
   * @param {Object} options - Query options
   * @returns {Promise<Array>} List of users
   */
  async getAllUsers(options = {}) {
    const {
      page = 1,
      limit = 10,
      active = true
    } = options;
    const result = await userRepository.findActiveWithPagination({}, {
      page,
      limit,
      select: '-password'
    });
    return result;
  }

  /**
   * Toggle favorite destination
   * @param {string} userId - User ID
   * @param {string} destinationId - Destination ID
   * @returns {Promise<Object>} Updated favorites
   */
  async toggleFavorite(userId, destinationId) {
    if (!destinationId) {
      throw new ValidationError('Destination ID is required');
    }
    const result = await userRepository.toggleFavorite(userId, destinationId);

    // Clear user cache
    await this.clearUserCache(userId);
    return {
      isFavorite: result.isFavorite,
      favorites: result.user.favorites
    };
  }

  /**
   * Get user's favorite destinations
   * @param {string} userId - User ID
   * @returns {Promise<Array>} Favorite destinations
   */
  async getFavorites(userId) {
    return await userRepository.getFavorites(userId);
  }

  /**
   * Calculate age from date of birth
   * @param {Date} dateOfBirth - Date of birth
   * @returns {number} Age
   */
  calculateAge(dateOfBirth) {
    const today = new Date();
    const birthDate = new Date(dateOfBirth);
    let age = today.getFullYear() - birthDate.getFullYear();
    const monthDiff = today.getMonth() - birthDate.getMonth();
    if (monthDiff < 0 || monthDiff === 0 && today.getDate() < birthDate.getDate()) {
      age--;
    }
    return age;
  }

  /**
   * Filter object to only include allowed fields
   * @param {Object} obj - Object to filter
   * @param {...string} allowedFields - Allowed field names
   * @returns {Object} Filtered object
   */
  filterAllowedFields(obj, ...allowedFields) {
    const newObj = {};
    Object.keys(obj).forEach(el => {
      if (allowedFields.includes(el)) {
        newObj[el] = obj[el];
      }
    });
    return newObj;
  }

  /**
   * Clear user-related cache
   * @param {string} userId - User ID
   * @returns {Promise<void>}
   */
  async clearUserCache(userId) {
    try {
      const cacheKeys = [`user:${userId}`, `user:profile:${userId}`, `user:favorites:${userId}`];
      await Promise.all(cacheKeys.map(key => this.deleteCachedData(key)));
    } catch (error) {
      // Log error but don't throw - cache clearing is not critical
      console.warn('Failed to clear user cache:', error.message);
    }
  }

  /**
   * Get user by ID with caching
   * @param {string} userId - User ID
   * @returns {Promise<Object>} User data
   */
  async getUserById(userId) {
    const cacheKey = `user:${userId}`;
    try {
      // Try to get from cache first
      let user = await this.getCachedData(cacheKey);
      if (!user) {
        user = await userRepository.findById(userId, {
          select: '-password',
          lean: true
        });
        if (user) {
          // Cache for 15 minutes
          await this.cacheData(cacheKey, user, 900);
        }
      }
      return user;
    } catch (error) {
      // If cache fails, fall back to database
      return await userRepository.findById(userId, {
        select: '-password',
        lean: true
      });
    }
  }
}
module.exports = new UserService();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJ1c2VyUmVwb3NpdG9yeSIsInJlcXVpcmUiLCJWYWxpZGF0aW9uRXJyb3IiLCJVbmF1dGhvcml6ZWRFcnJvciIsIk5vdEZvdW5kRXJyb3IiLCJDb25mbGljdEVycm9yIiwicmVkaXNVdGlscyIsIkNPVU5UUklFUyIsIkJhc2VTZXJ2aWNlIiwiVXNlclNlcnZpY2UiLCJyZWdpc3RlciIsInVzZXJEYXRhIiwiZW1haWwiLCJwYXNzd29yZCIsIm5hbWUiLCJkYXRlT2ZCaXJ0aCIsIm5hdGlvbmFsaXR5IiwiZXhpc3RpbmdVc2VyIiwiZmluZEJ5RW1haWwiLCJmb3JtYXR0ZWREYXRlT2ZCaXJ0aCIsIkRhdGUiLCJ1bmRlZmluZWQiLCJ1c2VyIiwiY3JlYXRlIiwidG9rZW4iLCJnZW5lcmF0ZUF1dGhUb2tlbiIsImxvZ2luIiwiY3JlZGVudGlhbHMiLCJmaW5kQnlFbWFpbFdpdGhQYXNzd29yZCIsImNvbXBhcmVQYXNzd29yZCIsImdldFByb2ZpbGUiLCJ1c2VySWQiLCJmaW5kQnlJZCIsInNlbGVjdCIsImxlYW4iLCJhZ2UiLCJjYWxjdWxhdGVBZ2UiLCJjb3VudHJ5IiwiZmluZCIsImMiLCJjb3VudHJ5Q29kZSIsImNvZGUiLCJ1cGRhdGVQcm9maWxlIiwidXBkYXRlRGF0YSIsImZpbHRlcmVkRGF0YSIsImZpbHRlckFsbG93ZWRGaWVsZHMiLCJ1cGRhdGVkVXNlciIsInVwZGF0ZUJ5SWQiLCJ1cGRhdGVQYXNzd29yZCIsInBhc3N3b3JkRGF0YSIsImN1cnJlbnRQYXNzd29yZCIsIm5ld1Bhc3N3b3JkIiwiZGVsZXRlQWNjb3VudCIsInNvZnREZWxldGUiLCJjbGVhclVzZXJDYWNoZSIsImdldEFsbFVzZXJzIiwib3B0aW9ucyIsInBhZ2UiLCJsaW1pdCIsImFjdGl2ZSIsInJlc3VsdCIsImZpbmRBY3RpdmVXaXRoUGFnaW5hdGlvbiIsInRvZ2dsZUZhdm9yaXRlIiwiZGVzdGluYXRpb25JZCIsImlzRmF2b3JpdGUiLCJmYXZvcml0ZXMiLCJnZXRGYXZvcml0ZXMiLCJ0b2RheSIsImJpcnRoRGF0ZSIsImdldEZ1bGxZZWFyIiwibW9udGhEaWZmIiwiZ2V0TW9udGgiLCJnZXREYXRlIiwib2JqIiwiYWxsb3dlZEZpZWxkcyIsIm5ld09iaiIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwiZWwiLCJpbmNsdWRlcyIsImNhY2hlS2V5cyIsIlByb21pc2UiLCJhbGwiLCJtYXAiLCJrZXkiLCJkZWxldGVDYWNoZWREYXRhIiwiZXJyb3IiLCJjb25zb2xlIiwid2FybiIsIm1lc3NhZ2UiLCJnZXRVc2VyQnlJZCIsImNhY2hlS2V5IiwiZ2V0Q2FjaGVkRGF0YSIsImNhY2hlRGF0YSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlcyI6WyJ1c2VyLnNlcnZpY2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgdXNlclJlcG9zaXRvcnkgPSByZXF1aXJlKCcuLi9yZXBvc2l0b3JpZXMvdXNlci5yZXBvc2l0b3J5Jyk7XG5jb25zdCB7IFZhbGlkYXRpb25FcnJvciwgVW5hdXRob3JpemVkRXJyb3IsIE5vdEZvdW5kRXJyb3IsIENvbmZsaWN0RXJyb3IgfSA9IHJlcXVpcmUoJy4uL3V0aWxzL2Vycm9ycycpO1xuY29uc3QgeyByZWRpc1V0aWxzIH0gPSByZXF1aXJlKCcuLi9taWRkbGV3YXJlL3JlZGlzQ2FjaGUnKTtcbmNvbnN0IENPVU5UUklFUyA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvdW50cmllcycpO1xuY29uc3QgQmFzZVNlcnZpY2UgPSByZXF1aXJlKCcuL2Jhc2Uuc2VydmljZScpO1xuXG5jbGFzcyBVc2VyU2VydmljZSBleHRlbmRzIEJhc2VTZXJ2aWNlIHtcbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgbmV3IHVzZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IHVzZXJEYXRhIC0gVXNlciByZWdpc3RyYXRpb24gZGF0YVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBVc2VyIGFuZCB0b2tlblxuICAgKi9cbiAgYXN5bmMgcmVnaXN0ZXIodXNlckRhdGEpIHtcbiAgICBjb25zdCB7IGVtYWlsLCBwYXNzd29yZCwgbmFtZSwgZGF0ZU9mQmlydGgsIG5hdGlvbmFsaXR5IH0gPSB1c2VyRGF0YTtcblxuICAgIC8vIENoZWNrIGlmIHVzZXIgYWxyZWFkeSBleGlzdHNcbiAgICBjb25zdCBleGlzdGluZ1VzZXIgPSBhd2FpdCB1c2VyUmVwb3NpdG9yeS5maW5kQnlFbWFpbChlbWFpbCk7XG4gICAgaWYgKGV4aXN0aW5nVXNlcikge1xuICAgICAgdGhyb3cgbmV3IENvbmZsaWN0RXJyb3IoJ0VtYWlsIGFscmVhZHkgcmVnaXN0ZXJlZCcpO1xuICAgIH1cblxuICAgIC8vIEZvcm1hdCBkYXRlT2ZCaXJ0aCB0byBoYW5kbGUgdGltZXpvbmUgaXNzdWVzXG4gICAgY29uc3QgZm9ybWF0dGVkRGF0ZU9mQmlydGggPSBkYXRlT2ZCaXJ0aCA/IG5ldyBEYXRlKGRhdGVPZkJpcnRoKSA6IHVuZGVmaW5lZDtcblxuICAgIC8vIENyZWF0ZSBuZXcgdXNlclxuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB1c2VyUmVwb3NpdG9yeS5jcmVhdGUoe1xuICAgICAgZW1haWwsXG4gICAgICBwYXNzd29yZCxcbiAgICAgIG5hbWUsXG4gICAgICBkYXRlT2ZCaXJ0aDogZm9ybWF0dGVkRGF0ZU9mQmlydGgsXG4gICAgICBuYXRpb25hbGl0eVxuICAgIH0pO1xuXG4gICAgLy8gR2VuZXJhdGUgdG9rZW5cbiAgICBjb25zdCB0b2tlbiA9IHVzZXIuZ2VuZXJhdGVBdXRoVG9rZW4oKTtcblxuICAgIC8vIFJlbW92ZSBwYXNzd29yZCBmcm9tIG91dHB1dFxuICAgIHVzZXIucGFzc3dvcmQgPSB1bmRlZmluZWQ7XG5cbiAgICByZXR1cm4geyB1c2VyLCB0b2tlbiB9O1xuICB9XG5cbiAgLyoqXG4gICAqIExvZ2luIHVzZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IGNyZWRlbnRpYWxzIC0gTG9naW4gY3JlZGVudGlhbHNcbiAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gVXNlciBhbmQgdG9rZW5cbiAgICovXG4gIGFzeW5jIGxvZ2luKGNyZWRlbnRpYWxzKSB7XG4gICAgY29uc3QgeyBlbWFpbCwgcGFzc3dvcmQgfSA9IGNyZWRlbnRpYWxzO1xuXG4gICAgLy8gQ2hlY2sgaWYgZW1haWwgYW5kIHBhc3N3b3JkIGV4aXN0XG4gICAgaWYgKCFlbWFpbCB8fCAhcGFzc3dvcmQpIHtcbiAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoJ1BsZWFzZSBwcm92aWRlIGVtYWlsIGFuZCBwYXNzd29yZCcpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHVzZXIgZXhpc3RzICYmIHBhc3N3b3JkIGlzIGNvcnJlY3RcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgdXNlclJlcG9zaXRvcnkuZmluZEJ5RW1haWxXaXRoUGFzc3dvcmQoZW1haWwpO1xuXG4gICAgaWYgKCF1c2VyIHx8ICEoYXdhaXQgdXNlci5jb21wYXJlUGFzc3dvcmQocGFzc3dvcmQpKSkge1xuICAgICAgdGhyb3cgbmV3IFVuYXV0aG9yaXplZEVycm9yKCdJbnZhbGlkIGNyZWRlbnRpYWxzJyk7XG4gICAgfVxuXG4gICAgLy8gR2VuZXJhdGUgdG9rZW5cbiAgICBjb25zdCB0b2tlbiA9IHVzZXIuZ2VuZXJhdGVBdXRoVG9rZW4oKTtcblxuICAgIC8vIFJlbW92ZSBwYXNzd29yZCBmcm9tIG91dHB1dFxuICAgIHVzZXIucGFzc3dvcmQgPSB1bmRlZmluZWQ7XG5cbiAgICByZXR1cm4geyB1c2VyLCB0b2tlbiB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB1c2VyIHByb2ZpbGUgYnkgSURcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCAtIFVzZXIgSURcbiAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gVXNlciBwcm9maWxlIHdpdGggY29tcHV0ZWQgZmllbGRzXG4gICAqL1xuICBhc3luYyBnZXRQcm9maWxlKHVzZXJJZCkge1xuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB1c2VyUmVwb3NpdG9yeS5maW5kQnlJZCh1c2VySWQsIHtcbiAgICAgIHNlbGVjdDogJy1wYXNzd29yZCcsXG4gICAgICBsZWFuOiB0cnVlXG4gICAgfSk7XG5cbiAgICBpZiAoIXVzZXIpIHtcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEVycm9yKCdVc2VyIG5vdCBmb3VuZCcpO1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSBhZ2UgaWYgZGF0ZU9mQmlydGggZXhpc3RzXG4gICAgaWYgKHVzZXIuZGF0ZU9mQmlydGgpIHtcbiAgICAgIHVzZXIuYWdlID0gdGhpcy5jYWxjdWxhdGVBZ2UodXNlci5kYXRlT2ZCaXJ0aCk7XG4gICAgfVxuXG4gICAgLy8gR2V0IGNvdW50cnkgY29kZSBpZiBuYXRpb25hbGl0eSBleGlzdHNcbiAgICBpZiAodXNlci5uYXRpb25hbGl0eSkge1xuICAgICAgY29uc3QgY291bnRyeSA9IENPVU5UUklFUy5maW5kKGMgPT4gYy5uYW1lID09PSB1c2VyLm5hdGlvbmFsaXR5KTtcbiAgICAgIGlmIChjb3VudHJ5KSB7XG4gICAgICAgIHVzZXIuY291bnRyeUNvZGUgPSBjb3VudHJ5LmNvZGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHVzZXI7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHVzZXIgcHJvZmlsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkIC0gVXNlciBJRFxuICAgKiBAcGFyYW0ge09iamVjdH0gdXBkYXRlRGF0YSAtIERhdGEgdG8gdXBkYXRlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IFVwZGF0ZWQgdXNlciBwcm9maWxlXG4gICAqL1xuICBhc3luYyB1cGRhdGVQcm9maWxlKHVzZXJJZCwgdXBkYXRlRGF0YSkge1xuICAgIC8vIERvbid0IGFsbG93IHBhc3N3b3JkIHVwZGF0ZXMgaGVyZVxuICAgIGlmICh1cGRhdGVEYXRhLnBhc3N3b3JkKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFxuICAgICAgICAnVGhpcyByb3V0ZSBpcyBub3QgZm9yIHBhc3N3b3JkIHVwZGF0ZXMuIFBsZWFzZSB1c2UgL2F1dGgvdXBkYXRlLXBhc3N3b3JkJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBGaWx0ZXIgb3V0IHVud2FudGVkIGZpZWxkcyB0aGF0IGFyZSBub3QgYWxsb3dlZCB0byBiZSB1cGRhdGVkXG4gICAgY29uc3QgZmlsdGVyZWREYXRhID0gdGhpcy5maWx0ZXJBbGxvd2VkRmllbGRzKHVwZGF0ZURhdGEsICduYW1lJywgJ2VtYWlsJywgJ2RhdGVPZkJpcnRoJywgJ25hdGlvbmFsaXR5Jyk7XG5cbiAgICBjb25zdCB1cGRhdGVkVXNlciA9IGF3YWl0IHVzZXJSZXBvc2l0b3J5LnVwZGF0ZUJ5SWQodXNlcklkLCBmaWx0ZXJlZERhdGEsIHtcbiAgICAgIHNlbGVjdDogJy1wYXNzd29yZCdcbiAgICB9KTtcblxuICAgIC8vIENhbGN1bGF0ZSBhZ2UgaWYgZGF0ZU9mQmlydGggZXhpc3RzXG4gICAgaWYgKHVwZGF0ZWRVc2VyLmRhdGVPZkJpcnRoKSB7XG4gICAgICB1cGRhdGVkVXNlci5hZ2UgPSB0aGlzLmNhbGN1bGF0ZUFnZSh1cGRhdGVkVXNlci5kYXRlT2ZCaXJ0aCk7XG4gICAgfVxuXG4gICAgLy8gR2V0IGNvdW50cnkgY29kZSBpZiBuYXRpb25hbGl0eSBleGlzdHNcbiAgICBpZiAodXBkYXRlZFVzZXIubmF0aW9uYWxpdHkpIHtcbiAgICAgIGNvbnN0IGNvdW50cnkgPSBDT1VOVFJJRVMuZmluZChjID0+IGMubmFtZSA9PT0gdXBkYXRlZFVzZXIubmF0aW9uYWxpdHkpO1xuICAgICAgaWYgKGNvdW50cnkpIHtcbiAgICAgICAgdXBkYXRlZFVzZXIuY291bnRyeUNvZGUgPSBjb3VudHJ5LmNvZGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHVwZGF0ZWRVc2VyO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB1c2VyIHBhc3N3b3JkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgLSBVc2VyIElEXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXNzd29yZERhdGEgLSBDdXJyZW50IGFuZCBuZXcgcGFzc3dvcmRcbiAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gTmV3IHRva2VuXG4gICAqL1xuICBhc3luYyB1cGRhdGVQYXNzd29yZCh1c2VySWQsIHBhc3N3b3JkRGF0YSkge1xuICAgIGNvbnN0IHsgY3VycmVudFBhc3N3b3JkLCBuZXdQYXNzd29yZCB9ID0gcGFzc3dvcmREYXRhO1xuXG4gICAgaWYgKCFjdXJyZW50UGFzc3dvcmQgfHwgIW5ld1Bhc3N3b3JkKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKCdQbGVhc2UgcHJvdmlkZSBjdXJyZW50IGFuZCBuZXcgcGFzc3dvcmQnKTtcbiAgICB9XG5cbiAgICBjb25zdCB1c2VyID0gYXdhaXQgdXNlclJlcG9zaXRvcnkuZmluZEJ5SWQodXNlcklkLCB7IHNlbGVjdDogJytwYXNzd29yZCcgfSk7XG5cbiAgICBpZiAoIXVzZXIpIHtcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEVycm9yKCdVc2VyIG5vdCBmb3VuZCcpO1xuICAgIH1cblxuICAgIGlmICghKGF3YWl0IHVzZXIuY29tcGFyZVBhc3N3b3JkKGN1cnJlbnRQYXNzd29yZCkpKSB7XG4gICAgICB0aHJvdyBuZXcgVW5hdXRob3JpemVkRXJyb3IoJ0N1cnJlbnQgcGFzc3dvcmQgaXMgaW5jb3JyZWN0Jyk7XG4gICAgfVxuXG4gICAgYXdhaXQgdXNlclJlcG9zaXRvcnkudXBkYXRlUGFzc3dvcmQodXNlcklkLCBuZXdQYXNzd29yZCk7XG5cbiAgICAvLyBHZXQgdXBkYXRlZCB1c2VyIHRvIGdlbmVyYXRlIG5ldyB0b2tlblxuICAgIGNvbnN0IHVwZGF0ZWRVc2VyID0gYXdhaXQgdXNlclJlcG9zaXRvcnkuZmluZEJ5SWQodXNlcklkKTtcbiAgICBjb25zdCB0b2tlbiA9IHVwZGF0ZWRVc2VyLmdlbmVyYXRlQXV0aFRva2VuKCk7XG5cbiAgICByZXR1cm4geyB0b2tlbiB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSB1c2VyIGFjY291bnQgKHNvZnQgZGVsZXRlKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkIC0gVXNlciBJRFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIGFzeW5jIGRlbGV0ZUFjY291bnQodXNlcklkKSB7XG4gICAgYXdhaXQgdXNlclJlcG9zaXRvcnkuc29mdERlbGV0ZSh1c2VySWQpO1xuXG4gICAgLy8gQ2xlYXIgdXNlci1yZWxhdGVkIGNhY2hlXG4gICAgYXdhaXQgdGhpcy5jbGVhclVzZXJDYWNoZSh1c2VySWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbGwgdXNlcnMgKGFkbWluIG9ubHkpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gUXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheT59IExpc3Qgb2YgdXNlcnNcbiAgICovXG4gIGFzeW5jIGdldEFsbFVzZXJzKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgcGFnZSA9IDEsIGxpbWl0ID0gMTAsIGFjdGl2ZSA9IHRydWUgfSA9IG9wdGlvbnM7XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB1c2VyUmVwb3NpdG9yeS5maW5kQWN0aXZlV2l0aFBhZ2luYXRpb24oe30sIHtcbiAgICAgIHBhZ2UsXG4gICAgICBsaW1pdCxcbiAgICAgIHNlbGVjdDogJy1wYXNzd29yZCdcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlIGZhdm9yaXRlIGRlc3RpbmF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgLSBVc2VyIElEXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkZXN0aW5hdGlvbklkIC0gRGVzdGluYXRpb24gSURcbiAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gVXBkYXRlZCBmYXZvcml0ZXNcbiAgICovXG4gIGFzeW5jIHRvZ2dsZUZhdm9yaXRlKHVzZXJJZCwgZGVzdGluYXRpb25JZCkge1xuICAgIGlmICghZGVzdGluYXRpb25JZCkge1xuICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcignRGVzdGluYXRpb24gSUQgaXMgcmVxdWlyZWQnKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB1c2VyUmVwb3NpdG9yeS50b2dnbGVGYXZvcml0ZSh1c2VySWQsIGRlc3RpbmF0aW9uSWQpO1xuXG4gICAgLy8gQ2xlYXIgdXNlciBjYWNoZVxuICAgIGF3YWl0IHRoaXMuY2xlYXJVc2VyQ2FjaGUodXNlcklkKTtcblxuICAgIHJldHVybiB7XG4gICAgICBpc0Zhdm9yaXRlOiByZXN1bHQuaXNGYXZvcml0ZSxcbiAgICAgIGZhdm9yaXRlczogcmVzdWx0LnVzZXIuZmF2b3JpdGVzXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdXNlcidzIGZhdm9yaXRlIGRlc3RpbmF0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkIC0gVXNlciBJRFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheT59IEZhdm9yaXRlIGRlc3RpbmF0aW9uc1xuICAgKi9cbiAgYXN5bmMgZ2V0RmF2b3JpdGVzKHVzZXJJZCkge1xuICAgIHJldHVybiBhd2FpdCB1c2VyUmVwb3NpdG9yeS5nZXRGYXZvcml0ZXModXNlcklkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgYWdlIGZyb20gZGF0ZSBvZiBiaXJ0aFxuICAgKiBAcGFyYW0ge0RhdGV9IGRhdGVPZkJpcnRoIC0gRGF0ZSBvZiBiaXJ0aFxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBBZ2VcbiAgICovXG4gIGNhbGN1bGF0ZUFnZShkYXRlT2ZCaXJ0aCkge1xuICAgIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKTtcbiAgICBjb25zdCBiaXJ0aERhdGUgPSBuZXcgRGF0ZShkYXRlT2ZCaXJ0aCk7XG4gICAgbGV0IGFnZSA9IHRvZGF5LmdldEZ1bGxZZWFyKCkgLSBiaXJ0aERhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICBjb25zdCBtb250aERpZmYgPSB0b2RheS5nZXRNb250aCgpIC0gYmlydGhEYXRlLmdldE1vbnRoKCk7XG5cbiAgICBpZiAobW9udGhEaWZmIDwgMCB8fCAobW9udGhEaWZmID09PSAwICYmIHRvZGF5LmdldERhdGUoKSA8IGJpcnRoRGF0ZS5nZXREYXRlKCkpKSB7XG4gICAgICBhZ2UtLTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbHRlciBvYmplY3QgdG8gb25seSBpbmNsdWRlIGFsbG93ZWQgZmllbGRzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBPYmplY3QgdG8gZmlsdGVyXG4gICAqIEBwYXJhbSB7Li4uc3RyaW5nfSBhbGxvd2VkRmllbGRzIC0gQWxsb3dlZCBmaWVsZCBuYW1lc1xuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBGaWx0ZXJlZCBvYmplY3RcbiAgICovXG4gIGZpbHRlckFsbG93ZWRGaWVsZHMob2JqLCAuLi5hbGxvd2VkRmllbGRzKSB7XG4gICAgY29uc3QgbmV3T2JqID0ge307XG4gICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgaWYgKGFsbG93ZWRGaWVsZHMuaW5jbHVkZXMoZWwpKSB7XG4gICAgICAgIG5ld09ialtlbF0gPSBvYmpbZWxdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXdPYmo7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgdXNlci1yZWxhdGVkIGNhY2hlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgLSBVc2VyIElEXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgYXN5bmMgY2xlYXJVc2VyQ2FjaGUodXNlcklkKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNhY2hlS2V5cyA9IFtcbiAgICAgICAgYHVzZXI6JHt1c2VySWR9YCxcbiAgICAgICAgYHVzZXI6cHJvZmlsZToke3VzZXJJZH1gLFxuICAgICAgICBgdXNlcjpmYXZvcml0ZXM6JHt1c2VySWR9YFxuICAgICAgXTtcblxuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIGNhY2hlS2V5cy5tYXAoa2V5ID0+IHRoaXMuZGVsZXRlQ2FjaGVkRGF0YShrZXkpKVxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gTG9nIGVycm9yIGJ1dCBkb24ndCB0aHJvdyAtIGNhY2hlIGNsZWFyaW5nIGlzIG5vdCBjcml0aWNhbFxuICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gY2xlYXIgdXNlciBjYWNoZTonLCBlcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHVzZXIgYnkgSUQgd2l0aCBjYWNoaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgLSBVc2VyIElEXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IFVzZXIgZGF0YVxuICAgKi9cbiAgYXN5bmMgZ2V0VXNlckJ5SWQodXNlcklkKSB7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBgdXNlcjoke3VzZXJJZH1gO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIFRyeSB0byBnZXQgZnJvbSBjYWNoZSBmaXJzdFxuICAgICAgbGV0IHVzZXIgPSBhd2FpdCB0aGlzLmdldENhY2hlZERhdGEoY2FjaGVLZXkpO1xuXG4gICAgICBpZiAoIXVzZXIpIHtcbiAgICAgICAgdXNlciA9IGF3YWl0IHVzZXJSZXBvc2l0b3J5LmZpbmRCeUlkKHVzZXJJZCwge1xuICAgICAgICAgIHNlbGVjdDogJy1wYXNzd29yZCcsXG4gICAgICAgICAgbGVhbjogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodXNlcikge1xuICAgICAgICAgIC8vIENhY2hlIGZvciAxNSBtaW51dGVzXG4gICAgICAgICAgYXdhaXQgdGhpcy5jYWNoZURhdGEoY2FjaGVLZXksIHVzZXIsIDkwMCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVzZXI7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIElmIGNhY2hlIGZhaWxzLCBmYWxsIGJhY2sgdG8gZGF0YWJhc2VcbiAgICAgIHJldHVybiBhd2FpdCB1c2VyUmVwb3NpdG9yeS5maW5kQnlJZCh1c2VySWQsIHtcbiAgICAgICAgc2VsZWN0OiAnLXBhc3N3b3JkJyxcbiAgICAgICAgbGVhbjogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFVzZXJTZXJ2aWNlKCk7Il0sIm1hcHBpbmdzIjoiQUFBQSxNQUFNQSxjQUFjLEdBQUdDLE9BQU8sQ0FBQyxpQ0FBaUMsQ0FBQztBQUNqRSxNQUFNO0VBQUVDLGVBQWU7RUFBRUMsaUJBQWlCO0VBQUVDLGFBQWE7RUFBRUM7QUFBYyxDQUFDLEdBQUdKLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQztBQUN2RyxNQUFNO0VBQUVLO0FBQVcsQ0FBQyxHQUFHTCxPQUFPLENBQUMsMEJBQTBCLENBQUM7QUFDMUQsTUFBTU0sU0FBUyxHQUFHTixPQUFPLENBQUMsb0JBQW9CLENBQUM7QUFDL0MsTUFBTU8sV0FBVyxHQUFHUCxPQUFPLENBQUMsZ0JBQWdCLENBQUM7QUFFN0MsTUFBTVEsV0FBVyxTQUFTRCxXQUFXLENBQUM7RUFDcEM7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUNFLE1BQU1FLFFBQVFBLENBQUNDLFFBQVEsRUFBRTtJQUN2QixNQUFNO01BQUVDLEtBQUs7TUFBRUMsUUFBUTtNQUFFQyxJQUFJO01BQUVDLFdBQVc7TUFBRUM7SUFBWSxDQUFDLEdBQUdMLFFBQVE7O0lBRXBFO0lBQ0EsTUFBTU0sWUFBWSxHQUFHLE1BQU1qQixjQUFjLENBQUNrQixXQUFXLENBQUNOLEtBQUssQ0FBQztJQUM1RCxJQUFJSyxZQUFZLEVBQUU7TUFDaEIsTUFBTSxJQUFJWixhQUFhLENBQUMsMEJBQTBCLENBQUM7SUFDckQ7O0lBRUE7SUFDQSxNQUFN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