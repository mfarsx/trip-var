{"version":3,"names":["asyncHandler","fn","req","res","next","Promise","resolve","catch","asyncServiceHandler","serviceMethod","args","error","logError","require","message","stack","method","name","length","withRetry","operation","maxRetries","delay","lastError","attempt","statusCode","setTimeout","withTimeout","timeoutMs","race","_","reject","Error","batchOperations","operations","concurrency","results","i","batch","slice","batchResults","allSettled","map","push","result","status","value","reason","module","exports"],"sources":["asyncHandler.js"],"sourcesContent":["/**\n * Async handler wrapper to catch errors in async route handlers\n * @param {Function} fn - Async function to wrap\n * @returns {Function} Express middleware function\n */\nconst asyncHandler = (fn) => {\n  return (req, res, next) => {\n    Promise.resolve(fn(req, res, next)).catch(next);\n  };\n};\n\n/**\n * Async handler for service methods\n * @param {Function} serviceMethod - Service method to wrap\n * @returns {Function} Wrapped service method\n */\nconst asyncServiceHandler = (serviceMethod) => {\n  return async(...args) => {\n    try {\n      return await serviceMethod(...args);\n    } catch (error) {\n      // Log service errors\n      const { error: logError } = require('./logger');\n      logError('Service error', {\n        error: error.message,\n        stack: error.stack,\n        method: serviceMethod.name,\n        args: args.length\n      });\n      throw error;\n    }\n  };\n};\n\n/**\n * Retry wrapper for operations that might fail\n * @param {Function} operation - Operation to retry\n * @param {number} maxRetries - Maximum number of retries\n * @param {number} delay - Delay between retries in ms\n * @returns {Promise<*>} Operation result\n */\nconst withRetry = async(operation, maxRetries = 3, delay = 1000) => {\n  let lastError;\n\n  for (let attempt = 1; attempt <= maxRetries; attempt++) {\n    try {\n      return await operation();\n    } catch (error) {\n      lastError = error;\n\n      // Don't retry on validation errors or authentication errors\n      if (error.statusCode && error.statusCode < 500) {\n        throw error;\n      }\n\n      if (attempt === maxRetries) {\n        throw error;\n      }\n\n      // Wait before retrying\n      await new Promise(resolve => setTimeout(resolve, delay * attempt));\n    }\n  }\n\n  throw lastError;\n};\n\n/**\n * Timeout wrapper for operations\n * @param {Function} operation - Operation to wrap\n * @param {number} timeoutMs - Timeout in milliseconds\n * @returns {Promise<*>} Operation result\n */\nconst withTimeout = (operation, timeoutMs = 5000) => {\n  return Promise.race([\n    operation(),\n    new Promise((_, reject) =>\n      setTimeout(() => reject(new Error('Operation timeout')), timeoutMs)\n    )\n  ]);\n};\n\n/**\n * Batch operation handler\n * @param {Array<Function>} operations - Array of operations to execute\n * @param {number} concurrency - Maximum concurrent operations\n * @returns {Promise<Array>} Results of all operations\n */\nconst batchOperations = async(operations, concurrency = 5) => {\n  const results = [];\n\n  for (let i = 0; i < operations.length; i += concurrency) {\n    const batch = operations.slice(i, i + concurrency);\n    const batchResults = await Promise.allSettled(\n      batch.map(operation => operation())\n    );\n\n    results.push(...batchResults.map(result =>\n      result.status === 'fulfilled' ? result.value : result.reason\n    ));\n  }\n\n  return results;\n};\n\nmodule.exports = {\n  asyncHandler,\n  asyncServiceHandler,\n  withRetry,\n  withTimeout,\n  batchOperations\n};"],"mappings":"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","ignoreList":[]}